#+TITLE:LLVM IR总结
#+OPTIONS: ^:nil
* Static single assignment form
SSA是IR的一种性质，要求每个变量只赋值一次。每个变量必须先声明或者定义再使用。通常对原有变量添加后缀生成新的变量，例如：
#+BEGIN_SRC C
y = 1;
y = 2;
x = y;
#+END_SRC
转换成SSA的形式为：
#+BEGIN_SRC
y_1 = 1;
y_2 = 2;
x_1 = y_2;
#+END_SRC
在分支选择时，会使用Phi函数，目前尚不清楚llvm IR何时使用phi指令，当前下面图片的示例生成的IR表示没有出现phi指令，初步生成
的IR表示，将变量以alloca指令分配到stack上，然后借助临时变量完成计算。
[[./SSA_example1.1.png][原始]][[./SSA_example1.2.png][SSA形式]][[./SSA_example1.3.png][phi函数形式]]

* automatic variable
自动变量（Automatic Variable）指的是局部作用域变量，具体来说即是在控制流进入变量作用域时系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。

* Identifiers
根据类型分为2类：

1、全局identifiers（functions，global variables），前缀为@。

2、局部identifiers（register names，types），前缀为%。

根据用途有3种格式：

1、Named values（非编译器生成的临时变量）由前缀加上字符串组成。它们的正则表达式形式为：'[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*'

2、Unnamed values 形示为unsigned numeric value加上前缀。例如%12，@2。

3、Constants。

LLVM 要求前缀的原因：

1、避免和reserved words冲突。

2、unamed identifiers让编译器能快速确定一个temporary variable，而不会和symbol table 冲突。
#+BEGIN_SRC
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
#+END_src
上面3行IR代码表明如下3点LLVM IR的语法特性：
1、以分号；为注释的起始符。
2、unnamed temporaries 主要用于中间计算，即计算结果没有被赋值给named value。
3、unnamed temporaries 的数字部分是从0开始顺序命名的。basic block的label和 unnamed 函数参数也包含在这个顺序中，

* high level structure
** module structure
LLVM的程序结构如下（缩进表示包含关系）：
#+BEGIN_SRC
programs:
        modules:输入程序编译的基本单元，llvm linker merges function (global variables) definitions，解析forward声明关系，merge symbol tables将modules连接在一起。
                global variables
                functions
                symbol table entries
#+END_SRC
** linkage types
所有的全局变量和函数有如下的类型的linkage:

1、private
linkage为private表示该global values只能被当前module的成员直接访问。将包含private global value的code link到一个module时，为了避免冲突可能会对该private global value重命名。

2、internal
和private类似，只能被当前module中的成员访问，global value作为object file中的local symbol（local variable），它和C语言中的static关键字对应。

3、available_externally
拥有这种linkage的globals不会在它所在的module生成的目标文件中生成代码指令。从linker的角度，available_externally global 等价于 external declaration。有利于inlining和
其他的一些优化。这种linkage type只能出现在definitions，不能出现在declarations。

4、linkonce
在链接时，将此类的global和其他同名的global merge。unreferenced linkonce globals 能被删除。能被用于实现某种形式的inlining functions, templates或其他代码，开启inlining和其它optimizations使用linkonce_odr linkage。

5、weak
和linkonce类似，但是unreferenced weak globals不能被删除。这种类型被用于C源码中声明为weak的globals。

6、common
和weak类似，但是用于C语言中的tentative definitions。common symbols 可能没有explicit section，必须有一个0 initializer，无法被标记为constant，不适用于functions和aliases。

7、appending
只能用于指向array的全局变量指针。当两个appending的全局指针链接时，这两个array合并到一起。

8、extern_weak
这种linkage在语义上遵循ELF目标文件格式，symbol在链接前都是weak，如果没有被链接，symbol则变成null而不是undefined reference。

9、linkonce_odr, weak_odr
遵循one definition rule的原则，使用linkonce_odr,weak_odr来标示只有等价(same semantics)的globals才能合并。

10、external
如果上面的linkage都没有被用到，则global在链接过程被用于解析external symbol reference。

除了external，external_weak，全局变量或函数的声明不能有其他类型的linkage type。

*** translate unit
源文件经过预处理（头文件包含，宏替换，条件编译等）成为translate unit。

*** one definition rule
这是一个重要的C++规则：

1、在任意translation unit内，template，type，function，object只能有一个定义。

2、在整个程序内，object或者non-inline function只能有一个定义。

3、types，templates，extern inline functions能在多个translation unit内定义。

*** object
an object can be a variable, a data structure, a function, or a method, and as such, is a value in memory referenced by an identifier。

*** tentative definition
declarations are known as external declarations because they appear outside of any function.

A tentative definition is any external data declaration that has no storage class specifier and no initializer。

*** inline function
编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。

** calling conventions
调用约定（Calling Convention）是规定子过程如何获取参数以及如何返回的方案，其通常与架构、编译器等相关。具体来说，调用约定一般规定了

a、参数、返回值、返回地址等放置的位置（寄存器、栈或存储器等）

b、如何将调用子过程的准备工作与恢复现场的工作划分到调用者（Caller）与被调用者（Callee）身上

llvm 的function, call和invoke指令前有一个可选的标注calling convention的选项。有如下的类型：

1、ccc：C calling convention
如果没有指定其它的calling conventions，这个是默认的。这种calling conventions支持变长度参数的function调用，允许函数一定程度的declared prototype和implemented declaration不匹配。

2、fastcc：fast calling convention
尝试让函数调用尽可能的快（例如通过在寄存器中传递数据的方式）。它允许target使用一切手段生成针对target 的fast code，而不用遵守外部的特定的ABI， 不支持变长度参数函数，
要求函数的声明和定义必须完全匹配。

3、coldcc：cold calling convention
尝试使caller内的代码尽可能的高效基于该调用不经常执行这一假设。这种calling convention 不支持边长度参数函数，要求函数的声明和定义必须完全匹配，内联器不会
将这类函数进行内联。

4、cc 10：GHC convention
专为Glasgow Haskell Compiler使用，通过寄存器传递一切数据。

5、cc 11：HiPE calling convention
专为 High-Performance Erlang(HiPE)使用，相对于通常的C calling convention，它使用更多的寄存器进行参数传递。

6、webkit_jscc：WebKit’s JavaScript calling convention
这种calling convention为WebKit FTL JIT实现，它在stack上从右到左进行参数传递（和cdecl calling convention一样的传递方式），使用平台定制的寄存器保存返回值。

7、anyregcc：Dynamic calling convention for code patching
支持 patching an arbitrary code sequence 以替换call site，只能用于llvm.experimental.patchpoint 相关的calls。

8、preserve_mostcc：The PreserveMost calling convention
尽可能的使得caller中的代码unintrusive，这种calling convention在参数和返回值如何传递上和C calling convention一致，但是使用了不同的 caller/callee-saved registers。

9、preserve_allcc：The PreserveAll calling convention
这种调用约定目的是让caller中的code更加的unintrusive。在参数和返回值的传递上，它的方式和C calling convention一样，但是使用了不同的caller/callee 保存的寄存器集。这
中约定的想法是在不需要调出其它函数的情形下，调用runtime function。

10、cxx_fast_tlscc：The CXX_FAST_TLS calling convention for access functions
clang生成一个访问C++风格的TLS(thread local storage)的接口函数，这个接口函数通常有一个entry block，一个exit block和一个会在第一时间运行的initialization block。
entry 和 exit block 能访问一些TLS IR 变量，每一个访问接口都会转换成平台相关的指令序列。这种calling convention目的在于通过尽可能多的保存register值来最小化caller的开销。
这种calling convention在参数和返回值如何传递上和C calling convention一致，但是使用了不同的 caller/callee-saved registers。

11、“swiftcc” - 这种 calling convention 用于 Swift language.
在 x86-64 平台上 RCX 和 R8 寄存器可以用于额外的整数返回值， XMM2 和 XMM3 可以用于额外的 FP/vector 返回值，在 iOS平台，我们使用 AAPCS-VFP calling convention。

12、“tailcc” - Tail callable calling convention
这种calling convention 确保在尾部位置的calls总是会执行tail call optimized。这种calling convention 等价于fastcc，除了会保证如果可能tail call的指令一定会生成。tail call
只有在 tailcc，fastcc，GHC或者HiPE convention被使用的时候才会被优化。这种calling convention 不支持变长度参数函数并且要求所有callee的声明和定义保持一致。

13、“cfguard_checkcc” - Windows Control Flow Guard (Check mechanism)
这种calling convention 用于 Control Flow Guard 检测函数，可以在间接调用之前检测函数，以检查调用函数的地址是否有效。检测函数没有返回值，但是会引起OS-level的error，如果
地址是无效的，

14、“cc <n>” - Numbered convention
任何calling convention 都可以指定一个number, 允许使用target-specific calling conventions. Target specific calling conventions start at 64.

** visibility styles
所有的全局变量和函数有如下的类型的visibility styles：

1、default
在使用ELF文件格式的目标平台上，default visibility表示：声明对其它module可见，并且在共享库里，则该声明的实体能被覆盖。在Darwin系统上，default visibility表示声明对其它module是
可见的。default visibility对应于external linkage。

2、hidden
拥有hidden visibility的对象的两个声明引用同一个object如果声明在同一个共享的object中。通常hidden visibility修饰的symbol不会被放在dynamic symbol table，因此other module
(executable or shared library) 不能直接引用它。

3、protected
在ELF文件里，protected visibility表明该symbol会放在dynamic symbol table里，但是在它的定义所在的module中的references会和local symbol 绑定，该symbol 不能被其它module覆盖。

拥有internal 或者 private linkage的symbol 必定拥有default visibility。

** DLL storage class (Dynamic link library)
所有的全局变量，函数以及Aliases只能有如下DLL storage class 之一：

1、dllimport
dllimport使得编译器通过一个全局的指针的指针来引用function和variable，这个全局的指针的指针通过DLL exporting symbol创建。
在微软平台上，指针的名字由__imp_结合函数或变量名来确定。

2、dllexport
dllexport使得编译器在DLL里提供一个全局的指针的指针，这样它在引用时能带有dllimport attribute。在微软平台上，指针的名字由__imp_结合函数或变量名来确定。

** Thread Local storage models
一个变量被定义为thread_local的，则它不会被threads共享，每个thread都会单独copy一份这个变量。

1、localdynamic
用于只在当前共享库中使用的variables。

2、initialexec
用于module中不会被动态载入的variables。

3、localexec
用于只在executable中定义和使用的variables。

如果没有给出上述三种model之一，则使用general dynamic model，它对应于ELF TLS model。

TLS model也能用于alias，但是它只控制alias如何被访问，而不会对aliasee产生影响。

对于不支持 ELF TLS的平台，可以使用-femulated-tls flag来生成兼容GCC的仿TLS代码。

** Runtime Preemption specifiers
全局变量，函数，aliases有一个可选的runtime preemption specifier。如果没有给定则symbol默认的runtime preemption specifier为dso_preemptable。

1、dso_preemptable
表示functions或者variables能在运行时被外部链接单元的symbol替换。

2、dso_local
编译器假定runtime preemption specifier为dso_local的函数或变量会解析到当前链接单元。将会生成直接的访问接口，即使真正的定义不在当前的编译单元。

** structure type
llvm IR 允许指定identified structure 和 literal structure type。identified structure 结构不唯一， literal structure结构唯一。

identified structure举例：
#+BEGIN_SRC
%mytype = type { %mytype*, i32 }
#+END_SRC

** Non-integral Pointer Type
目前这种类型处于实验状态。

** global variable
1、全局变量所占有的memory在编译时而不是程序运行的时候分配。

2、全局变量定义时必须被初始化。

3、可以声明在其它translation units中的全局变量，这时它们可以没有初始化（在当前translation unit）。

4、全局变量有一个linkage可选项。

5、全局变量的定义或声明能有一个explicit section存放，并且有一个alignment可选项。如果变量声明的section information和
它的定义不匹配，就会产生undefined resulting behavior。

6、被定义为global constant的变量的值无法修改，需要在runtime时初始化的variable无法被标记为constant。

7、llvm 允许全局变量在声明时标记为constant，即使它的最终定义不是constant。

8、作为SSA类型的值，global variables所定义的指针的作用域是程序中所有的basic blocks。全局变量的值（内容）通过指针访问。

9、Global variable能被标记为unnamed_addr，这表明它的地址不重要，它指向的内容才重要。标记为unnamed_addr的constants能和其它的constants合并，如果它们拥有相同的
初始化。拥有significant address 的constants和unnamed_addr的constants合并后形成的constants的address是significnat的。

10、如果给定local_unnamed_addr属性，则它的address在当前module内都不重要。

11、一个global variable能被声明驻留在平台相关的标号的地址空间里，对于支持这种操作的target，address space可能会影响优化以及target使用什么指令访问该变量。默认
的address space是0。地址空间的qualifier必须位于其它属性之前。

12、LLVM 允许将一块section指定为global。global 能放在comdat如果target支持。

13、external declaration 可能对应一个特定的section。section information保留在llvm ir中，将section information和附加在external declaration上则表示一种推断：
它的声明一定位于该section。

14、默认情况下，global initializer会被优化基于假设：定义在当前module内的全局变量的初始值在执行initializer前都不会修改。

15、global的alignment必须得是2的幂次，如果没有提供alignment，或者被设为0，target会根据需要来设置它的取值。最大的alignment为1<<29。

16、全局变量的声明或定义能在链接时被替换(linkage type：linkonce, weak, extern_weak, common)。llvm 不对variable分配的memory size作预设，但要求它们不重叠。

17、全局变量还有其它一些可选项：global attributes, metadata。变量和aliases可以有thread local storage model选项。Scalable vector无法成为global variable，
或者结构体成员，数组成员，因为它们的size在编译时是未知的。

语法：
#+BEGIN_SRC
@<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]
                   [DLLStorageClass] [ThreadLocal]
                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
                   [ExternallyInitialized]
                   <global | constant> <Type> [<InitializerConstant>]
                   [, section "name"] [, comdat [($name)]]
                   [, align <Alignment>] (, !name !N)*
#+END_SRC

** functions
定义：
#+BEGIN_SRC
define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
       [section "name"] [comdat [($name)]] [align N] [gc] [prefix Constant]
       [prologue Constant] [personality Constant] (!name !N)* { ... }
#+END_SRC
参数列表中的参数以逗号分隔，每个参数的形式为：
#+BEGIN_SRC
<type> [parameter Attrs] [name]
#+END_SRC
声明：
#+BEGIN_SRC
declare [linkage] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
       [align N] [gc] [prefix Constant]
       [prologue Constant]
#+END_SRC
每个函数定义包含一系列basic blocks，形成该函数的Control Flow Graph。每个basic block有一个可选项label（用于此basic block在symbol table中的入口），并以此开头，
包含一连串的instructions，以terminator instruction（branch或函数返回instruction）结尾。如果没有显式的给出label，block会得到一个隐式的数字编号的label，这个数
字label基于函数内的一个计数器生成。

LLVM 允许将一块显式的section指定为function，函数能被放置在COMDAT。

alignment可以显式的给出，它必须是2的幂次，如果没有给出，或者设置为0，则alignment的值将交由target来根据情况设置。

如果 unnamed_addr 被设置，则该address 不重要，两个相同的function会被合并。

如果 local_unnamed_addr被设置，则该address在当前所属的module内不重要。

如果没有显示的给出address space，则address space的值将从datalayout string中或得。

** Aliases
不产生新的新的数据，是existing position的一个symbol和metadata

Aliases有一个name和一个aliasee，aliasee要么是global value要么是constant expression。

语法：
#+BEGIN_SRC
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>
#+END_SRC
linkage的取值只能是private, internal, linkonce，weak，linkonce_odr，weak_odr，external之一。

设置unnamed_addr则alias的地址将和aliasee的地址指向同一object，没有设置unnamed_addr则它们拥有相同的address。

local_unnamed_addr的含义和前面介绍的一样。

关于aliases的一些限制：
1、aliasee所指代的expression必须可计算在assembly time，relocation无法使用。
2、expression中的alias不能是weak类型的。
3、expression中的global value 不能是declaration。

** IFuncs
不产生新的数据或函数，是dynamic linker在runtime时调用resolver function 解析的一个symbol。
IFuncs有一个name和resolver，这个resolver是一个函数，dynamic linker调用该函数返回另一个和这个name相关联的函数的地址。
语法：
#+BEGIN_SRC
@<Name> = [Linkage] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>
#+END_SRC

** Comdats
关于comdat section的解释：

The purpose of a COMDAT section is to allow "duplicate" sections to be defined in multiple object files. Normally, if the same symbol is defined in multiple object files,
the linker will report errors. This can cause problems for some C++ language features, like templates, that may instantiate the same symbols in different cpp files.

COMDAT sections are used to get around this. When a section is marked as a COMDAT in an object file, it also specifies a flag that indicates how conflicts should be resolved.
There are a bunch of options, including "just pick anyone you like", "make sure all dups. are the same size", "make sure all dups. have the same content", "pick the largest
one", etc. See the COFF spec for a complete list.

There's no requirements, one way or the other, on what the contents of a COMDAT section has to be. They can contain one procedure, many procedures, data, or any combination
of both code and data.

补充解释：

A Comdat section is a section in the object file, in which objects are placed, which can be duplicated in other object files. Each object has information for the linker,
indicating what it must do when duplicates are detected. The options can be: Any — do anything, ExactMatch — duplicates must completely match, otherwise an error occurs,
Largest — take the object with the largest value, NoDublicates — there should not be a duplicate, SameSize — duplicates must have the same size, otherwise an error occurs.

总的来说：
comdat用来存储重复定义的object，针对每个object给出链接时处理的方式。

LLVM comdat 提供访问COFF和ELF目标文件中COMDAT section的功能。

Comdats 有个一个代表COMDAT key 的name，如果linker选择了这个key，所有绑定这个key的global objects会出现在最后的object file，Aliases会放在它们对应的aliasee计算的COMDAT内。

Comdats有一个选择类型，可提供有关链接器如何在两个不同目标文件中的键之间进行选择的输入。

语法：
#+BEGIN_SRC
$<Name> = comdat SelectionKind
#+END_SRC

selectionKind为下列选项之一：
1、any:
linker 选择任意的COMDAT key
2、exactmatch
linker 可以选择任意的key，但是sections 的数据必须相同
3、largest
linker 选择包含最大的COMDAT key 的section。
4、noduplicates
linker 要求只有这种COMDAT key的section存在
5、samesize
linker 可以选择任意的COMDAT key，但是各section必须包含相同数量的数据

举例：
#+BEGIN_SRC
$foo = comdat largest
@foo = global i32 2, comdat($foo)

define void @bar() comdat($foo) {
  ret void
}
#+END_SRC
在COFF目标文件中，这将会创建一个COMDAT section，它的selection_kind为largest，包含@foo符号，另一个COMDAT section，它的selection_kind为ASSOCIATIVE，它和
第一个COMDAT section相关联，包含@bar符号。

在生成COFF object file时要求global object 和 它的 alias 的名字和COMDAT group 名字相同。global object 的linkage 不能是local。

** Named Metadata
Named Metadata 是 metadata的合集，Metadata node 是named metadat唯一合法的操作数。它的name由感叹号前缀加上string构成，不允许quoted name，允许转义字符。
举例：
#+BEGIN_SRC
; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!"zero"}
!1 = !{!"one"}
!2 = !{!"two"}
; A named metadata.
!name = !{!0, !1, !2}
#+END_SRC

** Parameter Attributes
函数的返回值和参数值有参数属性，参数属性用来传递函数参数和返回值的额外信息，函数属性是函数的一部分，不是function type，因此有不同parameter attributes的function
可以有相同的function type。

参数属性位于parameter的type后，若有多个attribute，则它们之间用空格隔开。
举例：
#+BEGIN_SRC
declare i32 @printf(i8* noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
#+END_SRC
函数result的attribute(nounwind, readonly)位于参数列表之后。

现有如下参数属性：
1、zeroext
这向code generator表明：它所修饰的参数或返回值是zero-extended在target ABI所要求的范围内（对caller是parameter，对callee是返回值）。

2、signext
这向code generator表明：它所修饰的参数或返回值是sign-extended在target ABI（通常是32位）所要求的范围内（对caller是parameter，对callee是返回值）。

3、inreg
这表明这个参数或返回值在生成函数调用或返回的代码时，应该以一种特殊的和target相关的方式来处理，（通常将它放在寄存器中，而不是放在内存中）这个属性的使用是target-specific。

4、byval or byval（<ty>）（值传递）
这表明指针的值才是实际传递给函数的，这隐含着caller和callee间指针的拷贝，因此callee无法修改caller中的值，这个属性只能用于llvm 指针参数。它通常用于结构体或数组的
值传递，也可用于scalar。copy属于caller。这个属性无法用于返回值。

byval也支持可选的type参数（<ty>），这个ty必须和pointee类型相同。

byval 属性也支持指定一个alignment，如果alignment 没有给定，code generator 会根据target 来做出决定。

5、byref（<ty>）（引用传递）
byref允许给定pointee的memory类型参数，这类似于byval，但不存在copy操作，参数通过stack来传递，通常不允许对byref pointer进行写操作，这种属性不适用于return value。
同byval一样，它也可以指定一个alignment。它主要用于表现ABI 的 constraints，无法被optimization使用。

6、preallocated（<ty>）(类似于指向数组的指针)
这表明指针的值才是实际传递给函数的，而且pointer指向的内容pointee已经被初始化了在函数调用前，这种属性只适用于LLVM pointer arguments.
这个参数必须是由llvm.call.preallocated.arg在非musttail 调用时的返回值。或者对应的在musttail call中caller 的参数。

这种属性也支持可选的type参数（<ty>），这个ty必须和pointee类型相同。

这种属性也支持指定一个alignment，如果alignment 没有给定，code generator 会根据target 来做出决定。

7、inalloca
这个属性使得caller可以取outgoing stack arguments的地址。inalloca的参数必须是由alloca instruction产生的指向stack memory的一个指针。alloca或allocation参数，必须
也被标记上inalloca keyword。只有最后一个参数才有inalloca属性，而且这个参数保证会在memory中传递。

一个在memory中分配的参数，只能被一次调用使用一次，因为call可能会收回它的memory，inalloca属性无法和其它的影响参数存储的的属性一起使用，例如like inreg, nest, sret,
byval等。

8、sret or sret(<ty>)
这表明指针参数包含了源程序中一个函数返回值的结构的地址，这个地址必须由caller来保证其有效性。这种属性不适用于返回值。ty可选项的含义同上。

9、align <n> or align(<n>)
这表明指针的值会被optimizer假定具有特定的对齐。如果pointer没有具体的对齐值，则会带来为定义的行为。align 1对non-byval,non-preallocated参数没有影响。
当它和byval或者preallocated结合时会有额外的含义。

10、noalias
???

11、nocapture
这表明callee不会复制任何超过自身范围的pointer。这种属性不适用于返回值。用于volatile operations的address被认为是captured的。

12、nofree
这表明callee不会释放pointer参数，这种属性不适用于返回值。

13、nest
这表明指针参数可以剥离通过trampoline 函数，这种属性不适用于返回值，且只能用于一个参数。

14、returned
这表明函数将总是将该参数作为它的返回值。这会提示optimizer和code generator在生成caller时，允许使用value propagation，tail call optimization ，在某些情况下忽略掉寄存器
保存和恢复的值。参数和函数的返回类型必须是一个bitcast指令的合法操作数。这种属性不适用于返回值，只能用于一个参数。

15、nonnull
这表明参数或返回的指针是非null的，这种属性只能用于指针类型的参数，如果参数或返回值是null，则会产生为定义的行为，llvm不会强制进行检测。

16、dereferenceable(<n>)
这表明参数或返回的指针是dereferenceable（访问指针指向的值）。这种属性只能用于指针类型的参数，可被dereferenceable的字节数必须在括号内提供。允许字节数小于pointee的字节数。
nonnull属性并不意味着dereferenceable，

17、dereferenceable_or_null(<n>)
这表明参数或返回值不可能同时是null和non-dereferenceable的。

18、swiftself
这表明parameter是 self/context 参数，这种属性不适用于返回值，而且只能用于一个参数。

19、swifterror
这种属性来源于模仿和优化swift的error的处理，它只能用于带有指针的指针的参数或者指针大小的alloca。

20、immarg
这表明该参数是一个immediate value（不是存储在memory或者register中的值），undef或者constant expression 不合法，只能用于intrinsic declaration，不能用于call site和函数。

21、noundef
这种属性可以用于参数和返回值，如果value representation包含undefined或者posion bits，则会导致为定义的行为，这并不适用于type存储表示时引入的padding。

** Garbage Collector Strategy Names
每个函数都可以指定一个垃圾回收策略，它有如下形式：
#+BEGIN_SRC
define void @f() gc "name" { ... }
#+END_SRC
它支持的名字的取值包含在https://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies ，指定一个garbage collector会使编译器改变它的输出以支持那种名字的
garbage collector算法。llvm自身不提供garbage collector，这个功能限制在生成机器码的时候，此时可以将外部提供的collector插入。

** Prefix Data
prefix data是和函数关联的数据，code generator会在function entrypoint前立即生成。这个feature的目的是允许frontend将语言相关的runtime metadata和具体的函数相结合，
让这些信息可以通过函数指针获取在函数指针被调用的时候。

可以将函数指针转换成constant 类型的指针，访问index-1的内容来获取一个函数的prefix data。下面是获取prefix data的示例：
#+BEGIN_SRC
define void @f() prefix i32 123 { ... }
%0 = bitcast void* () @f to i32*
%a = getelementptr inbounds i32, i32* %0, i32 -1
%b = load i32, i32* %a
#+END_SRC
函数会被安排使得prefix data的开头是是对齐的。这意味着，如果prefix data的size不是alignment的倍数，函数的entrypoint将不会对齐。如果需要entrypoint对齐，就需要添加pad。

一个函数可能有prefix data但是没有函数主体，这在语义上类似于available_externally linkage，数据可能被用于optimize，但不会在object file中生成。

** Prologue Data
Prologue 属性允许任意字节编码的code插到函数体前。这能用于函数的hot-patching和检测
具体来说，它必须以字节序列开头，该字节序列解码为对模块目标有效的机器指令序列，该指令将控制权转移到Prologue data之后的点，而不执行任何其他可见的操作。
这使内联程序和其他pass可以推理出函数定义的语义，而无需理解Prologue Data。 这使得Prologue的格式target相关的。
举例：
#+BEGIN_SRC
define void @f() prologue i8 144 { ... }
#+END_SRC
一个函数可能有prologue Data但是没有函数主体，这和available_externally linkage中的情形有些类似，数据只被用于优化，而不会出现在最终的object file中生成。

** Personality Function
personality属性允许函数指定使用什么函数处理exception。

** Attribute Group
Attribute Group在IR中是一组供object引用的属性，它们对于.ll文件的可读性很重要，因为很多函数会使用相同的属性。
在最简单的情形，一个.ll文件对应一个.c文件，单个的attribute group将会捕捉重要的命令行参数来创建ll文件。

Attribute Group是一个module级别的object，可以通过引用attribute group ID的形式来使用attribute group。当一个
object使用多个attribute group时，不同组的attribute 会合并。

举例：
#+BEGIN_SRC
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { "no-sse" }

; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
#+END_SRC

** Function Attributes
Function attributes用于交流函数的额外的信息。Function attribute是函数的一部分，不是function type的一部分，因此拥有不同function attribute的函数
可以拥有相同的function type。

函数属性是排在function type后的一些关键字，如果有多个attribute，它们之间用空格隔开。例如：
#+BEGIN_SRC
define void @f() noinline { ... }
define void @f() alwaysinline { ... }
define void @f() alwaysinline optsize { ... }
define void @f() optsize { ... }
#+END_SRC
下面是各属性的解释：

1、alignstack(<n>)
这个属性表明，在生成开头和结尾代码时，backend应该强制要求栈指针对齐，对齐值必须是2的幂次值。

2、allocsize(<EltSizeParam>[, <NumEltsParam>])
这个属性表明
* runtime
Runtime describes software/instructions that are executed while your program is running, especially those instructions that you did not write explicitly,
but are necessary for the proper execution of your code.

* storage class
A storage class in the context of C++ variable declarations is a type specifier that governs the lifetime, linkage, and memory location of objects。
A given object can have only one storage class. Variables defined within a block have automatic storage unless otherwise specified using the extern, static,
or thread_local specifiers. Automatic objects and variables have no linkage; they are not visible to code outside the block. Memory is allocated for them
automatically when execution enters the block and de-allocated when the block is exited.

* outgoing stack arguments
the caller has a preallocated area at the top of its stack frame to hold the arguments it supplies to other subroutines it calls. This area is sometimes
termed the outgoing arguments area or callout area。
* storage class specifier
auto register static extern _Thread_local

* tail call
函数在code block的结尾被调用，即为tail call。

* store 指令
store指令用于写memory。
* load指令
load指令用于读memory.
* sub指令
sub返回两个操作数的差值
