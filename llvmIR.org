#+TITLE:LLVM IR总结
#+OPTIONS: ^:nil
* Static single assignment form
SSA是IR的一种性质，要求每个变量只赋值一次。每个变量必须先声明或者定义再使用。通常对原有变量添加后缀生成新的变量，例如：
#+BEGIN_SRC C
y = 1;
y = 2;
x = y;
#+END_SRC
转换成SSA的形式为：
#+BEGIN_SRC
y_1 = 1;
y_2 = 2;
x_1 = y_2;
#+END_SRC
在分支选择时，会使用Phi函数，目前尚不清楚llvm IR何时使用phi指令，当前下面图片的示例生成的IR表示没有出现phi指令，初步生成
的IR表示，将变量以alloca指令分配到stack上，然后借助临时变量完成计算。
[[./SSA_example1.1.png][原始]][[./SSA_example1.2.png][SSA形式]][[./SSA_example1.3.png][phi函数形式]]

* automatic variable
自动变量（Automatic Variable）指的是局部作用域变量，具体来说即是在控制流进入变量作用域时系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。

* Identifiers
根据类型分为2类：

1、全局identifiers（functions，global variables），前缀为@。

2、局部identifiers（register names，types），前缀为%。

根据用途有3种格式：

1、Named values（非编译器生成的临时变量）由前缀加上字符串组成。它们的正则表达式形式为：'[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*'

2、Unnamed values 形示为unsigned numeric value加上前缀。例如%12，@2。

3、Constants。

LLVM 要求前缀的原因：

1、避免和reserved words冲突。

2、unamed identifiers让编译器能快速确定一个temporary variable，而不会和symbol table 冲突。
#+BEGIN_SRC
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
#+END_src
上面3行IR代码表明如下3点LLVM IR的语法特性：
1、以分号；为注释的起始符。
2、unnamed temporaries 主要用于中间计算，即计算结果没有被赋值给named value。
3、unnamed temporaries 的数字部分是从0开始顺序命名的。basic block的label和 unnamed 函数参数也包含在这个顺序中，

* high level structure
** module structure
LLVM的程序结构如下（缩进表示包含关系）：
#+BEGIN_SRC
programs:
        modules:输入程序编译的基本单元，llvm linker merges function (global variables) definitions，解析forward声明关系，merge symbol tables将modules连接在一起。
                global variables
                functions
                symbol table entries
#+END_SRC
** linkage types
所有的全局变量和函数有如下的类型的linkage:

1、private
linkage为private表示该global values只能被当前module的成员直接访问。将包含private global value的code link到一个module时，为了避免冲突可能会对该private global value重命名。

2、internal
和private类似，只能被当前module中的成员访问，global value作为object file中的local symbol（local variable），它和C语言中的static关键字对应。

3、available_externally
拥有这种linkage的globals不会在它所在的module生成的目标文件中生成代码指令。从linker的角度，available_externally global 等价于 external declaration。有利于inlining和
其他的一些优化。这种linkage type只能出现在definitions，不能出现在declarations。

4、linkonce
在链接时，将此类的global和其他同名的global merge。unreferenced linkonce globals 能被删除。能被用于实现某种形式的inlining functions, templates或其他代码，开启inlining和其它optimizations使用linkonce_odr linkage。

5、weak
和linkonce类似，但是unreferenced weak globals不能被删除。这种类型被用于C源码中声明为weak的globals。

6、common
和weak类似，但是用于C语言中的tentative definitions。common symbols 可能没有explicit section，必须有一个0 initializer，无法被标记为constant，不适用于functions和aliases。

7、appending
只能用于指向array的全局变量指针。当两个appending的全局指针链接时，这两个array合并到一起。

8、extern_weak
这种linkage在语义上遵循ELF目标文件格式，symbol在链接前都是weak，如果没有被链接，symbol则变成null而不是undefined reference。

9、linkonce_odr, weak_odr
遵循one definition rule的原则，使用linkonce_odr,weak_odr来标示只有等价(same semantics)的globals才能合并。

10、external
如果上面的linkage都没有被用到，则global在链接过程被用于解析external symbol reference。

除了external，external_weak，全局变量或函数的声明不能有其他类型的linkage type。

*** translate unit
源文件经过预处理（头文件包含，宏替换，条件编译等）成为translate unit。

*** one definition rule
这是一个重要的C++规则：

1、在任意translation unit内，template，type，function，object只能有一个定义。

2、在整个程序内，object或者non-inline function只能有一个定义。

3、types，templates，extern inline functions能在多个translation unit内定义。

*** object
an object can be a variable, a data structure, a function, or a method, and as such, is a value in memory referenced by an identifier。

*** tentative definition
declarations are known as external declarations because they appear outside of any function.

A tentative definition is any external data declaration that has no storage class specifier and no initializer。

*** inline function
编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。

** calling conventions
调用约定（Calling Convention）是规定子过程如何获取参数以及如何返回的方案，其通常与架构、编译器等相关。具体来说，调用约定一般规定了

a、参数、返回值、返回地址等放置的位置（寄存器、栈或存储器等）

b、如何将调用子过程的准备工作与恢复现场的工作划分到调用者（Caller）与被调用者（Callee）身上

llvm 的function, call和invoke指令前有一个可选的标注calling convention的选项。有如下的类型：

1、ccc：C calling convention
如果没有指定其它的calling conventions，这个是默认的。这种calling conventions支持变长度参数的function调用，允许函数一定程度的declared prototype和implemented declaration不匹配。

2、fastcc：fast calling convention
尝试让函数调用尽可能的快（例如通过在寄存器中传递数据的方式）。它允许target使用一切手段生成针对target 的fast code，而不用遵守外部的特定的ABI， 不支持变长度参数函数，
要求函数的声明和定义必须完全匹配。

3、coldcc：cold calling convention
尝试使caller内的代码尽可能的高效基于该调用不经常执行这一假设。这种calling convention 不支持边长度参数函数，要求函数的声明和定义必须完全匹配，内联器不会
将这类函数进行内联。

4、cc 10：GHC convention
专为Glasgow Haskell Compiler使用，通过寄存器传递一切数据。

5、cc 11：HiPE calling convention
专为 High-Performance Erlang(HiPE)使用，相对于通常的C calling convention，它使用更多的寄存器进行参数传递。

6、webkit_jscc：WebKit’s JavaScript calling convention
这种calling convention为WebKit FTL JIT实现，它在stack上从右到左进行参数传递（和cdecl calling convention一样的传递方式），使用平台定制的寄存器保存返回值。

7、anyregcc：Dynamic calling convention for code patching
支持 patching an arbitrary code sequence 以替换call site，只能用于llvm.experimental.patchpoint 相关的calls。

8、preserve_mostcc：The PreserveMost calling convention
尽可能的使得caller中的代码unintrusive，这种calling convention在参数和返回值如何传递上和C calling convention一致，但是使用了不同的 caller/callee-saved registers。

9、preserve_allcc：The PreserveAll calling convention
这种调用约定目的是让caller中的code更加的unintrusive。在参数和返回值的传递上，它的方式和C calling convention一样，但是使用了不同的caller/callee 保存的寄存器集。这
中约定的想法是在不需要调出其它函数的情形下，调用runtime function。

10、cxx_fast_tlscc：The CXX_FAST_TLS calling convention for access functions
clang生成一个访问C++风格的TLS(thread local storage)的接口函数，这个接口函数通常有一个entry block，一个exit block和一个会在第一时间运行的initialization block。
entry 和 exit block 能访问一些TLS IR 变量，每一个访问接口都会转换成平台相关的指令序列。这种calling convention目的在于通过尽可能多的保存register值来最小化caller的开销。
这种calling convention在参数和返回值如何传递上和C calling convention一致，但是使用了不同的 caller/callee-saved registers。

11、“swiftcc” - 这种 calling convention 用于 Swift language.
在 x86-64 平台上 RCX 和 R8 寄存器可以用于额外的整数返回值， XMM2 和 XMM3 可以用于额外的 FP/vector 返回值，在 iOS平台，我们使用 AAPCS-VFP calling convention。

12、“tailcc” - Tail callable calling convention
这种calling convention 确保在尾部位置的calls总是会执行tail call optimized。这种calling convention 等价于fastcc，除了会保证如果可能tail call的指令一定会生成。tail call
只有在 tailcc，fastcc，GHC或者HiPE convention被使用的时候才会被优化。这种calling convention 不支持变长度参数函数并且要求所有callee的声明和定义保持一致。

13、“cfguard_checkcc” - Windows Control Flow Guard (Check mechanism)
这种calling convention 用于 Control Flow Guard 检测函数，可以在间接调用之前检测函数，以检查调用函数的地址是否有效。检测函数没有返回值，但是会引起OS-level的error，如果
地址是无效的，

14、“cc <n>” - Numbered convention
任何calling convention 都可以指定一个number, 允许使用target-specific calling conventions. Target specific calling conventions start at 64.

** visibility styles
所有的全局变量和函数有如下的类型的visibility styles：

1、default
在使用ELF文件格式的目标平台上，default visibility表示：声明对其它module可见，并且在共享库里，则该声明的实体能被覆盖。在Darwin系统上，default visibility表示声明对其它module是
可见的。default visibility对应于external linkage。

2、hidden
拥有hidden visibility的对象的两个声明引用同一个object如果声明在同一个共享的object中。通常hidden visibility修饰的symbol不会被放在dynamic symbol table，因此other module
(executable or shared library) 不能直接引用它。

3、protected
在ELF文件里，protected visibility表明该symbol会放在dynamic symbol table里，但是在它的定义所在的module中的references会和local symbol 绑定，该symbol 不能被其它module覆盖。

拥有internal 或者 private linkage的symbol 必定拥有default visibility。

** DLL storage class (Dynamic link library)
所有的全局变量，函数以及Aliases只能有如下DLL storage class 之一：

1、dllimport
dllimport使得编译器通过一个全局的指针的指针来引用function和variable，这个全局的指针的指针通过DLL exporting symbol创建。
在微软平台上，指针的名字由__imp_结合函数或变量名来确定。

2、dllexport
dllexport使得编译器在DLL里提供一个全局的指针的指针，这样它在引用时能带有dllimport attribute。在微软平台上，指针的名字由__imp_结合函数或变量名来确定。

** Thread Local storage models
一个变量被定义为thread_local的，则它不会被threads共享，每个thread都会单独copy一份这个变量。

1、localdynamic
用于只在当前共享库中使用的variables。

2、initialexec
用于module中不会被动态载入的variables。

3、localexec
用于只在executable中定义和使用的variables。

如果没有给出上述三种model之一，则使用general dynamic model，它对应于ELF TLS model。

TLS model也能用于alias，但是它只控制alias如何被访问，而不会对aliasee产生影响。

对于不支持 ELF TLS的平台，可以使用-femulated-tls flag来生成兼容GCC的仿TLS代码。

** Runtime Preemption specifiers
全局变量，函数，aliases有一个可选的runtime preemption specifier。如果没有给定则symbol默认的runtime preemption specifier为dso_preemptable。

1、dso_preemptable
表示functions或者variables能在运行时被外部链接单元的symbol替换。

2、dso_local
编译器假定runtime preemption specifier为dso_local的函数或变量会解析到当前链接单元。将会生成直接的访问接口，即使真正的定义不在当前的编译单元。

** structure type
llvm IR 允许指定identified structure 和 literal structure type。identified structure 结构不唯一， literal structure结构唯一。

identified structure举例：
#+BEGIN_SRC
%mytype = type { %mytype*, i32 }
#+END_SRC

** Non-integral Pointer Type
目前这种类型处于实验状态。

** global variable
1、全局变量所占有的memory在编译时而不是程序运行的时候分配。

2、全局变量定义时必须被初始化。

3、可以声明在其它translation units中的全局变量，这时它们可以没有初始化（在当前translation unit）。

4、全局变量有一个linkage可选项。

5、全局变量的定义或声明能有一个explicit section存放，并且有一个alignment可选项。如果变量声明的section information和
它的定义不匹配，就会产生undefined resulting behavior。

6、被定义为global constant的变量的值无法修改，需要在runtime时初始化的variable无法被标记为constant。

7、llvm 允许全局变量在声明时标记为constant，即使它的最终定义不是constant。

8、作为SSA类型的值，global variables所定义的指针的作用域是程序中所有的basic blocks。全局变量的值（内容）通过指针访问。

9、Global variable能被标记为unnamed_addr，这表明它的地址不重要，它指向的内容才重要。标记为unnamed_addr的constants能和其它的constants合并，如果它们拥有相同的
初始化。拥有significant address 的constants和unnamed_addr的constants合并后形成的constants的address是significnat的。

10、如果给定local_unnamed_addr属性，则它的address在当前module内都不重要。

11、一个global variable能被声明驻留在平台相关的标号的地址空间里，对于支持这种操作的target，address space可能会影响优化以及target使用什么指令访问该变量。默认
的address space是0。地址空间的qualifier必须位于其它属性之前。

12、LLVM 允许将一块section指定为global。global 能放在comdat如果target支持。

13、external declaration 可能对应一个特定的section。section information保留在llvm ir中，将section information和附加在external declaration上则表示一种推断：
它的声明一定位于该section。

14、默认情况下，global initializer会被优化基于假设：定义在当前module内的全局变量的初始值在执行initializer前都不会修改。

15、global的alignment必须得是2的幂次，如果没有提供alignment，或者被设为0，target会根据需要来设置它的取值。最大的alignment为1<<29。

16、全局变量的声明或定义能在链接时被替换(linkage type：linkonce, weak, extern_weak, common)。llvm 不对variable分配的memory size作预设，但要求它们不重叠。

17、全局变量还有其它一些可选项：global attributes, metadata。变量和aliases可以有thread local storage model选项。Scalable vector无法成为global variable，
或者结构体成员，数组成员，因为它们的size在编译时是未知的。

语法：
#+BEGIN_SRC
@<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]
                   [DLLStorageClass] [ThreadLocal]
                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
                   [ExternallyInitialized]
                   <global | constant> <Type> [<InitializerConstant>]
                   [, section "name"] [, comdat [($name)]]
                   [, align <Alignment>] (, !name !N)*
#+END_SRC

** functions
定义：
#+BEGIN_SRC
define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
       [section "name"] [comdat [($name)]] [align N] [gc] [prefix Constant]
       [prologue Constant] [personality Constant] (!name !N)* { ... }
#+END_SRC
参数列表中的参数以逗号分隔，每个参数的形式为：
#+BEGIN_SRC
<type> [parameter Attrs] [name]
#+END_SRC
声明：
#+BEGIN_SRC
declare [linkage] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
       [align N] [gc] [prefix Constant]
       [prologue Constant]
#+END_SRC
每个函数定义包含一系列basic blocks，形成该函数的Control Flow Graph。每个basic block有一个可选项label（用于此basic block在symbol table中的入口），并以此开头，
包含一连串的instructions，以terminator instruction（branch或函数返回instruction）结尾。如果没有显式的给出label，block会得到一个隐式的数字编号的label，这个数
字label基于函数内的一个计数器生成。

LLVM 允许将一块显式的section指定为function，函数能被放置在COMDAT。

alignment可以显式的给出，它必须是2的幂次，如果没有给出，或者设置为0，则alignment的值将交由target来根据情况设置。

如果 unnamed_addr 被设置，则该address 不重要，两个相同的function会被合并。

如果 local_unnamed_addr被设置，则该address在当前所属的module内不重要。

如果没有显示的给出address space，则address space的值将从datalayout string中或得。

** Aliases
不产生新的新的数据，是existing position的一个symbol和metadata

Aliases有一个name和一个aliasee，aliasee要么是global value要么是constant expression。

语法：
#+BEGIN_SRC
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>
#+END_SRC
linkage的取值只能是private, internal, linkonce，weak，linkonce_odr，weak_odr，external之一。

设置unnamed_addr则alias的地址将和aliasee的地址指向同一object，没有设置unnamed_addr则它们拥有相同的address。

local_unnamed_addr的含义和前面介绍的一样。

关于aliases的一些限制：
1、aliasee所指代的expression必须可计算在assembly time，relocation无法使用。
2、expression中的alias不能是weak类型的。
3、expression中的global value 不能是declaration。

** IFuncs
不产生新的数据或函数，是dynamic linker在runtime时调用resolver function 解析的一个symbol。
IFuncs有一个name和resolver，这个resolver是一个函数，dynamic linker调用该函数返回另一个和这个name相关联的函数的地址。
语法：
#+BEGIN_SRC
@<Name> = [Linkage] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>
#+END_SRC

** Comdats
关于comdat section的解释：

The purpose of a COMDAT section is to allow "duplicate" sections to be defined in multiple object files. Normally, if the same symbol is defined in multiple object files,
the linker will report errors. This can cause problems for some C++ language features, like templates, that may instantiate the same symbols in different cpp files.

COMDAT sections are used to get around this. When a section is marked as a COMDAT in an object file, it also specifies a flag that indicates how conflicts should be resolved.
There are a bunch of options, including "just pick anyone you like", "make sure all dups. are the same size", "make sure all dups. have the same content", "pick the largest
one", etc. See the COFF spec for a complete list.

There's no requirements, one way or the other, on what the contents of a COMDAT section has to be. They can contain one procedure, many procedures, data, or any combination
of both code and data.

补充解释：

A Comdat section is a section in the object file, in which objects are placed, which can be duplicated in other object files. Each object has information for the linker,
indicating what it must do when duplicates are detected. The options can be: Any — do anything, ExactMatch — duplicates must completely match, otherwise an error occurs,
Largest — take the object with the largest value, NoDublicates — there should not be a duplicate, SameSize — duplicates must have the same size, otherwise an error occurs.

总的来说：
comdat用来存储重复定义的object，针对每个object给出链接时处理的方式。

LLVM comdat 提供访问COFF和ELF目标文件中COMDAT section的功能。

Comdats 有个一个代表COMDAT key 的name，如果linker选择了这个key，所有绑定这个key的global objects会出现在最后的object file，Aliases会放在它们对应的aliasee计算的COMDAT内。

Comdats有一个选择类型，可提供有关链接器如何在两个不同目标文件中的键之间进行选择的输入。

语法：
#+BEGIN_SRC
$<Name> = comdat SelectionKind
#+END_SRC

selectionKind为下列选项之一：
1、any:
linker 选择任意的COMDAT key
2、exactmatch
linker 可以选择任意的key，但是sections 的数据必须相同
3、largest
linker 选择包含最大的COMDAT key 的section。
4、noduplicates
linker 要求只有这种COMDAT key的section存在
5、samesize
linker 可以选择任意的COMDAT key，但是各section必须包含相同数量的数据

举例：
#+BEGIN_SRC
$foo = comdat largest
@foo = global i32 2, comdat($foo)

define void @bar() comdat($foo) {
  ret void
}
#+END_SRC
在COFF目标文件中，这将会创建一个COMDAT section，它的selection_kind为largest，包含@foo符号，另一个COMDAT section，它的selection_kind为ASSOCIATIVE，它和
第一个COMDAT section相关联，包含@bar符号。

在生成COFF object file时要求global object 和 它的 alias 的名字和COMDAT group 名字相同。global object 的linkage 不能是local。

** Named Metadata
Named Metadata 是 metadata的合集，Metadata node 是named metadat唯一合法的操作数。它的name由感叹号前缀加上string构成，不允许quoted name，允许转义字符。
举例：
#+BEGIN_SRC
; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!"zero"}
!1 = !{!"one"}
!2 = !{!"two"}
; A named metadata.
!name = !{!0, !1, !2}
#+END_SRC

** Parameter Attributes
函数的返回值和参数值有参数属性，参数属性用来传递函数参数和返回值的额外信息，函数属性是函数的一部分，不是function type，因此有不同parameter attributes的function
可以有相同的function type。

参数属性位于parameter的type后，若有多个attribute，则它们之间用空格隔开。
举例：
#+BEGIN_SRC
declare i32 @printf(i8* noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
#+END_SRC
函数result的attribute(nounwind, readonly)位于参数列表之后。

现有如下参数属性：
1、zeroext
这向code generator表明：它所修饰的参数或返回值是zero-extended在target ABI所要求的范围内（对caller是parameter，对callee是返回值）。

2、signext
这向code generator表明：它所修饰的参数或返回值是sign-extended在target ABI（通常是32位）所要求的范围内（对caller是parameter，对callee是返回值）。

3、inreg
这表明这个参数或返回值在生成函数调用或返回的代码时，应该以一种特殊的和target相关的方式来处理，（通常将它放在寄存器中，而不是放在内存中）这个属性的使用是target-specific。

4、byval or byval（<ty>）（值传递）
这表明指针的值才是实际传递给函数的，这隐含着caller和callee间指针的拷贝，因此callee无法修改caller中的值，这个属性只能用于llvm 指针参数。它通常用于结构体或数组的
值传递，也可用于scalar。copy属于caller。这个属性无法用于返回值。

byval也支持可选的type参数（<ty>），这个ty必须和pointee类型相同。

byval 属性也支持指定一个alignment，如果alignment 没有给定，code generator 会根据target 来做出决定。

5、byref（<ty>）（引用传递）
byref允许给定pointee的memory类型参数，这类似于byval，但不存在copy操作，参数通过stack来传递，通常不允许对byref pointer进行写操作，这种属性不适用于return value。
同byval一样，它也可以指定一个alignment。它主要用于表现ABI 的 constraints，无法被optimization使用。

6、preallocated（<ty>）(类似于指向数组的指针)
这表明指针的值才是实际传递给函数的，而且pointer指向的内容pointee已经被初始化了在函数调用前，这种属性只适用于LLVM pointer arguments.
这个参数必须是由llvm.call.preallocated.arg在非musttail 调用时的返回值。或者对应的在musttail call中caller 的参数。

这种属性也支持可选的type参数（<ty>），这个ty必须和pointee类型相同。

这种属性也支持指定一个alignment，如果alignment 没有给定，code generator 会根据target 来做出决定。

7、inalloca
这个属性使得caller可以取outgoing stack arguments的地址。inalloca的参数必须是由alloca instruction产生的指向stack memory的一个指针。alloca或allocation参数，必须
也被标记上inalloca keyword。只有最后一个参数才有inalloca属性，而且这个参数保证会在memory中传递。

一个在memory中分配的参数，只能被一次调用使用一次，因为call可能会收回它的memory，inalloca属性无法和其它的影响参数存储的的属性一起使用，例如like inreg, nest, sret,
byval等。

8、sret or sret(<ty>)
这表明指针参数包含了源程序中一个函数返回值的结构的地址，这个地址必须由caller来保证其有效性。这种属性不适用于返回值。ty可选项的含义同上。

9、align <n> or align(<n>)
这表明指针的值会被optimizer假定具有特定的对齐。如果pointer没有具体的对齐值，则会带来为定义的行为。align 1对non-byval,non-preallocated参数没有影响。
当它和byval或者preallocated结合时会有额外的含义。

10、noalias
???

11、nocapture
这表明callee不会复制任何超过自身范围的pointer。这种属性不适用于返回值。用于volatile operations的address被认为是captured的。

12、nofree
这表明callee不会释放pointer参数，这种属性不适用于返回值。

13、nest
这表明指针参数可以剥离通过trampoline 函数，这种属性不适用于返回值，且只能用于一个参数。

14、returned
这表明函数将总是将该参数作为它的返回值。这会提示optimizer和code generator在生成caller时，允许使用value propagation，tail call optimization ，在某些情况下忽略掉寄存器
保存和恢复的值。参数和函数的返回类型必须是一个bitcast指令的合法操作数。这种属性不适用于返回值，只能用于一个参数。

15、nonnull
这表明参数或返回的指针是非null的，这种属性只能用于指针类型的参数，如果参数或返回值是null，则会产生为定义的行为，llvm不会强制进行检测。

16、dereferenceable(<n>)
这表明参数或返回的指针是dereferenceable（访问指针指向的值）。这种属性只能用于指针类型的参数，可被dereferenceable的字节数必须在括号内提供。允许字节数小于pointee的字节数。
nonnull属性并不意味着dereferenceable，

17、dereferenceable_or_null(<n>)
这表明参数或返回值不可能同时是null和non-dereferenceable的。

18、swiftself
这表明parameter是 self/context 参数，这种属性不适用于返回值，而且只能用于一个参数。

19、swifterror
这种属性来源于模仿和优化swift的error的处理，它只能用于带有指针的指针的参数或者指针大小的alloca。

20、immarg
这表明该参数是一个immediate value（不是存储在memory或者register中的值），undef或者constant expression 不合法，只能用于intrinsic declaration，不能用于call site和函数。

21、noundef
这种属性可以用于参数和返回值，如果value representation包含undefined或者posion bits，则会导致为定义的行为，这并不适用于type存储表示时引入的padding。

** Garbage Collector Strategy Names
每个函数都可以指定一个垃圾回收策略，它有如下形式：
#+BEGIN_SRC
define void @f() gc "name" { ... }
#+END_SRC
它支持的名字的取值包含在https://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies ，指定一个garbage collector会使编译器改变它的输出以支持那种名字的
garbage collector算法。llvm自身不提供garbage collector，这个功能限制在生成机器码的时候，此时可以将外部提供的collector插入。

** Prefix Data
prefix data是和函数关联的数据，code generator会在function entrypoint前立即生成。这个feature的目的是允许frontend将语言相关的runtime metadata和具体的函数相结合，
让这些信息可以通过函数指针获取在函数指针被调用的时候。

可以将函数指针转换成constant 类型的指针，访问index-1的内容来获取一个函数的prefix data。下面是获取prefix data的示例：
#+BEGIN_SRC
define void @f() prefix i32 123 { ... }
%0 = bitcast void* () @f to i32*
%a = getelementptr inbounds i32, i32* %0, i32 -1
%b = load i32, i32* %a
#+END_SRC
函数会被安排使得prefix data的开头是是对齐的。这意味着，如果prefix data的size不是alignment的倍数，函数的entrypoint将不会对齐。如果需要entrypoint对齐，就需要添加pad。

一个函数可能有prefix data但是没有函数主体，这在语义上类似于available_externally linkage，数据可能被用于optimize，但不会在object file中生成。

** Prologue Data
Prologue 属性允许任意字节编码的code插到函数体前。这能用于函数的hot-patching和检测
具体来说，它必须以字节序列开头，该字节序列解码为对模块目标有效的机器指令序列，该指令将控制权转移到Prologue data之后的点，而不执行任何其他可见的操作。
这使内联程序和其他pass可以推理出函数定义的语义，而无需理解Prologue Data。 这使得Prologue的格式target相关的。
举例：
#+BEGIN_SRC
define void @f() prologue i8 144 { ... }
#+END_SRC
一个函数可能有prologue Data但是没有函数主体，这和available_externally linkage中的情形有些类似，数据只被用于优化，而不会出现在最终的object file中生成。

** Personality Function
personality属性允许函数指定使用什么函数处理exception。

** Attribute Group
Attribute Group在IR中是一组供object引用的属性，它们对于.ll文件的可读性很重要，因为很多函数会使用相同的属性。
在最简单的情形，一个.ll文件对应一个.c文件，单个的attribute group将会捕捉重要的命令行参数来创建ll文件。

Attribute Group是一个module级别的object，可以通过引用attribute group ID的形式来使用attribute group。当一个
object使用多个attribute group时，不同组的attribute 会合并。

举例：
#+BEGIN_SRC
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { "no-sse" }

; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
#+END_SRC

** Function Attributes
Function attributes用于交流函数的额外的信息。Function attribute是函数的一部分，不是function type的一部分，因此拥有不同function attribute的函数
可以拥有相同的function type。

函数属性是排在function type后的一些关键字，如果有多个attribute，它们之间用空格隔开。例如：
#+BEGIN_SRC
define void @f() noinline { ... }
define void @f() alwaysinline { ... }
define void @f() alwaysinline optsize { ... }
define void @f() optsize { ... }
#+END_SRC
下面是各属性的解释：

1、alignstack(<n>)
这个属性表明，在生成开头和结尾代码时，backend应该强制要求栈指针对齐，对齐值必须是2的幂次值。

2、allocsize(<EltSizeParam>[, <NumEltsParam>])
这个属性表明annotated function总是至少返回一个给定数目字节数（或者NULL）。它的参数index从0开始编号。如果给定一个参数，则至少CallSite.Args[EltSizeParam]
个字节返回，如果提供两个参数则CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]个字节返回。引用的参数必须是整型。

3、alwaysinline
这个属性表明inliner会尽可能的内联这个函数，为caller忽略掉inlining size限制。

4、builtin
这个属性表明位于call site 处的callee会被当作built-in 函数，即使该函数的声明使用了nobuiltin属性。这个属性适用的情形：在call site 处直接调用声明带有nobuiltin
属性的函数。

5、cold
这个属性表明这个函数极少被调用。When computing edge weights（应用场景是什么?）, basic blocks post-dominated by a cold function call are also considered to be cold; and, thus, given low weight.

6、convergent
在某些并行执行的模型种，存在无法根据任何其他的值确立control-dependent的操作，llvm IR称这些operation 为 convergent。这个属性可能出现在function或者call/invoke指令。当出现在function，则这个函数的
调用不应是依赖于其它值的control-dependent的。当它出现在call/invoke时，我们应该将call当作calling convergent function。

7、inaccessiblememonly
这个属性表明该函数只能访问正在被编译的模块无法访问的memory。

8、inaccessiblemem_or_argmemonly
此属性表示该函数只能访问要么无法被正在编译的模块访问，要么由其指针参数指向的内存。

9、inlinehint
此属性表示源代码包含内联这个函数的暗示。

10、jumptable
此属性表示应在code-generation时将该函数添加到jump指令表中，并且对该函数的所有地址引用均应替换为对相应jump指令表函数指针的引用。 这将为原始函数创建一个新的指针，这意味着依赖于函数指针身份的代码可能会中断。
 因此，任何带有jumptable的函数也必须是unnamed_addr的。

11、minsize
此属性表明optimization pass和code generator pass会做出选择，以使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以最小化所生成代码的大小。

12、naked
此属性会关闭函数prologue/epilogue的生成。

13、"no-inline-line-tables"
当此属性设置为true时，内联程序在内联代码时会丢弃源位置，而是使用call site的源位置。

14、no-jump-tables
当此属性设置为true时，将禁用通过switch case lowering生成jump table 和 lookup table。

15、nobuiltin
这表明call site处的callee function不会被认定为built-in function。 LLVM将保留原始调用，并且不会根据built-in function的语义将其替换为等效代码，除非call site使用builtin属性。 这在call site以及函数声明和定义上有效。

16、noduplicates
此属性指示无法重复(duplicated)调用该函数。 调用noduplicate函数可以在其移到parent内，但不能在parent函数内重复。

17、nofree
此函数属性指示该函数没有直接或间接调用内存释放函数（例如free函数）。

18、noimplicitfloat
此属性禁用隐式浮点指令。

19、noinline
此属性表示inliner在任何情况下都不应内联此函数。

20、nomerge
此属性表示在优化过程中永远不要合并对此函数的调用。该属性使用户可以控制代码大小和调试信息精度之间的折衷。

21、nonlazybind
此属性抑制该函数的lazy symbol binding。

22、noredzone
此属性表明，即使target-specific ABI允许，代码生成器也不应使用red zone（？？？）。

23、indirect-tls-seg-refs
此属性表示code generator 不应使用通过段寄存器的直接TLS访问，即使target-specific ABI允许。

24、noreturn
此函数属性表示该函数从不正常返回，因此通过返回指令。 如果函数曾经动态返回，则会在运行时产生不确定的行为。

25、norecurse
此函数属性表示该函数不会直接或间接通过任何可能的调用路径进行调用自身（不会递归调用）。

26、willreturn
该函数属性表示对该函数的调用将显示未定义的行为，或者将返回并继续在现有调用堆栈中包含当前调用的某个点处执行。

27、nosync
该函数属性表示该函数不通过memory或其他well-defined的方式与另一个线程进行通信（同步）。

28、nounwind
该函数属性表示该函数从不引发异常。 如果函数确实引发异常，则其运行时行为未定义。

29、null_pointer_is_valid
如果设置了null_pointer_is_valid，则将地址空间0中的null address视为内存加载和存储的有效地址。 在该函数中，任何分析或优化都不应将dereferencing a pointer to null视为未定义的行为。

30、optforfuzzing
此属性表示应针对maximum fuzzing signal（？？？）优化此函数。

31、optnone
此函数属性表示大多数优化过程将跳过此函数，过程间优化除外。 code generator默认为 fast 指令选择器。 此属性不能与alwaysinline属性一起使用； 此属性也与minsize属性和optsize属性不兼容。

此属性还要求在函数上指定noinline属性，因此该函数永远不会内联到任何caller中。

32、optsize
此属性表明optimization passes和code generator passes会做出一些选择，以使该函数的代码量保持较低，否则，只要不显著影响运行时性能，就进行优化以减小代码量。

33、"patchable-function"
此属性告诉代码生成器，为此函数生成的代码需要遵循某些约定，以使运行时函数可以在以后对其进行修补。

34、"probe-stack"
此属性表示该函数将开辟堆栈末尾的保护区域。 这样可以确保对堆栈的访问不得超出保护区到堆栈先前访问区域的距离。

35、readnone
在函数上，此属性表示该函数严格根据其参数计算其结果（或决定解除异常），而无需访问任何指针参数指向的内容或以其他方式访问对caller function可见的任何可变状态（例如，内存，控制寄存器等）。
它不会写入任何指针参数（包括byval参数），并且永远不会更改caller可见的任何状态。这意味着尽管它无法通过调用C++异常抛出方法来消除异常（因为它们已写入内存），但可能存在非C++
机制抛出异常而未写入LLVM可见内存。

在参数上，此属性表示该函数不会访问该指针参数指向的内容，即使该函数可以通过其他指针进行访问也可以读取或写入该指针指向的内存。

36、readonly
在函数上，此属性表示该函数不会通过任何指针参数（包括byval参数）进行写操作，也不以其他方式修改caller function可见的任何状态（例如内存，控制寄存器等）。

对于参数，此属性表示该函数不会通过该指针参数进行写入，即使它可能会写入指针所指向的内存。

37、"stack-probe-size"
此属性控制堆栈检测的操作：“probe-stack”属性或ABI必需的堆栈检测（如果有）。 它定义了保护区域的大小。 它确保如果函数使用的堆栈空间大于保护区域的大小，则将发起堆栈检测。
它采用一个必需的整数值，默认情况下为4096。

38、"no-stack-arg-probe"
这个属性取消了ABI所需的stack probes，如果有。

39、writeonly
在函数上，这个属性表示该函数只写但不从memory读取内容。

在参数上，这个属性表示函数只通过这个指针写而不通过这个指针读取数据。

40、argmemonly
该属性表示函数内部唯一的memory访问是从其指针类型的参数所指向的对象（具有任意偏移量）进行的load和store。 换句话说，该函数中的所有memory操作只能使用基于其函数参数的指针
来访问memory。

请注意，argmemonly可以与readonly属性一起使用，以指定该函数仅从其参数读取。

41、returns_twice
此属性表示此函数可以返回两次。 C 的setjmp是这类函数的一个示例。 编译器会禁用这些函数的caller程序中的某些优化（例如tail calls）。

42、safestack
此属性表示此函数启用了SafeStack保护。

Safestack是一种instrumentation pass，可以保护程序免受基于堆栈缓冲区溢出的攻击，而不会增加任何明显的性能开销。

43、sanitize_address
此属性表示此函数启用了AddressSanitizer检查（动态地址安全分析）。

AddressSanitizer（或ASan）是Google的开源编程工具，可检测memory损坏错误，例如缓冲区溢出或对悬空指针（dangling pointer）的访问（访问释放后的指针）。

44、sanitize_memory
此属性表示该函数启用了MemorySanitizer检查（动态检测对未初始化memory的访问）。

45、sanitize_thread
此属性表示此函数启用了ThreadSanitizer检查（动态线程安全分析）。

46、sanitize_hwaddress
此属性表示此函数启用了HWAddressSanitizer检查（基于标记指针的动态地址安全性分析）。

47、sanitize_memtag
此属性表示此函数启用MemTagSanitizer检查（基于Armv8 MTE的动态地址安全分析）。

48、speculative_load_hardening
此属性表示此函数启用speculative load hardening。

speculative load hardening是一种削弱信息泄漏攻击的措施，该攻击利用控制流未命中（尤其是是否采用分支的未命中）进行信息泄漏攻击。
（https://llvm.org/docs/SpeculativeLoadHardening.html）

49、speculatable
该函数属性表示该函数除计算其结果外没有任何其它的影响，并且没有undefined behavior。

50、ssp
此属性表示函数应采用stack smashing protector。它采用“ canary”的形式：将随机值放置在堆栈上，然后从函数返回时检查局部变量，以查看其是否已被覆盖。

51、sspreq
此属性表示函数应采用stack smashing protector，它会覆盖ssp属性。

52、sspstrong
此属性表示函数应采用stack smashing protector。 在确定函数是否需要堆栈保护器时，此属性会导致使用强启发式。它会覆盖ssp属性。

53、strictfp
此属性表示从要求严格浮点语义的scope调用了该函数。

54、"denormal-fp-math"
这表示可以为默认浮点环境的进行异常处理。

55、"denormal-fp-math-f32"
同denormal-fp-math一样，但是处理的是32位浮点型。

56、thunk
此属性表示该函数将通过tail call委派给其他函数。

57、uwtable
此属性表示target ABI要求为此函数生成unwind table entry。

58、nocf_check
此属性表示将不会对属性实体执行控制流检查。

59、shadowcallstack
此属性表示该函数启用ShadowCallStack检查。 instrumentation会检查函数prolog和epilog之间函数的返回地址是否未更改。

60、mustprogress
此属性表示需要该函数以可观测的方式返回，展开或与环境交互。例如： 通过易失性存储器访问，I / O或其他同步。

** call site attributes
下列是专用于call site 的属性：

1、vector-function-abi-variant
该属性可以附加到调用中，以列出与该函数关联的vector function。 注意，该属性不能附加到invoke或callbr指令上。

当被设置时，该属性通知编译器此函数具有相应的vector variant（可用于对向量执行的并发调用）。

2、preallocated(<ty>)
调用llvm.call.preallocated.arg时需要此属性，而不能在任何其他call中使用。






** Global Attributes
对于全局变量也可以设置属性来传递更多的信息。全局变量的属性被分组为单个属性组（attribute group）。具体的可以查看attribute group。

** Operand Bundles
operand bundles是可以与某些LLVM指令（当前仅call和invoke）相关联的SSA value的tag集。 从某种意义上说，它们就像元数据，但是删除它们会改变程序的语义。

语法：
#+BEGIN_SRC
operand bundle set ::= '[' operand bundle (, operand bundle )* ']'
operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'
bundle operand ::= SSA value
tag ::= string constant
#+END_SRC
operand bundles是一种通用的机制，它为managed language提供类似runtime-introspection（type introspection）的功能。它的确切语义取决于bundle tag。

下面为一些具体的operand bundles的类型：

1、Deoptimization operand bundles

Deoptimization operand bundles 的对应的 operand bundle tag 值为 “deopt”。These operand bundles represent an alternate “safe” continuation for the call site
they’re attached to，可以由合适的运行时使用，以在指定的call site deoptimize已编译的帧。
从编译器的角度来看，deoptimization operand bundles 使它们连接的call site至少是只读的。它们会读取所有其指针类型的操作数（即使没有进行转义也是如此）和整个可见堆。

2、Funclet Operand Bundles
Funclet operand bundles的特征是“funclet” bundle tag。这些operand bundles表示call site在特定的funclet中。 call site最多可以连接一个“funclet” operand bundle，
并且它必须恰好具有一个operand bundle。

Funclet是父函数的区域，可以将其视为具有特殊调用约定的函数指针。

3、GC Transition Operand Bundles
GC转换operand bundles的特征在于“ gc-transition”operand bundle tag。这些operand bundles将call标记为具有一个GC策略的函数到具有不同GC策略的函数之间的transition。

4、Assume Operand Bundles
llvm.assume上的operand bundles允许表示这样的假设：参数属性或函数属性在特定位置具有特定值。

5、Preallocated Operand Bundles
Preallocated Operand Bundles的特征在于“preallocated”的operand bundle tag。这些operand bundles允许将call argument memory的分配与call site分开。

6、GC Live Operand Bundles
“gc-live” operand bundles 仅在 gc.statepoint intrinsic 上有效。 operand bundles必须包含指向垃圾收集对象的每个指针，该对象可能需要由垃圾收集器进行更新。

** Module-Level Inline Assembly
module可以包含“module-level inline asm”块，它对应于GCC“file scope inline asm”块。 这些块由LLVM在内部连接，并被视为一个单元，但如果需要，可以在.ll文件中分开。

语法：
#+BEGIN_SRC
module asm "inline asm code goes here"
module asm "more can go here"
#+END_SRC

** Data Layout
module可以指定target specific data layout 字符串，该字符串指定如何在内存中布局数据。

语法：
#+BEGIN_SRC
target datalayout = "layout specification"
#+END_SRC

layout字符串的内容由“-”（减号）分隔，具体参数如下：

E 表示target 数据以big-endian 形式存储。

e 表示target 数据以little-endian 形式存储。

S<size> 以位为单位指定堆栈的自然对齐方式。堆栈对齐必须是8位的倍数。

P<address space> 指定与程序存储器相对应的地址空间。

G<address space> 指定创建全局变量时默认使用的地址空间。如果省略，则全局地址空间默认为默认地址空间0。

A<address space> 指定由“alloca”创建的对象的地址空间。默认为默认地址空间0。

p[n]:<size>:<abi>:<pref>:<idx> 这指定了指针的大小以及地址空间n的<abi>和<pref> erred对齐方式。 第四个参数<idx>是用于地址计算的索引大小。
如果未指定，则默认索引大小等于指针大小。 所有大小均以位为单位。 地址空间n是可选的，如果未指定，则表示默认地址空间0。n的值必须在[1,2 ^ 23）
范围内。

i<size>:<abi>:<pref> 这指定给定位<size>的整数类型的alignment。 <size>的值必须在[1,2 ^ 23）范围内。

v<size>:<abi>:<pref> 这指定给定位<size>的vector类型的alignment。

f<size>:<abi>:<pref> 这指定给定位<size>的浮点类型的alignment。

a:<abi>:<pref> 这指定aggregate type （复合类型）的对象的alignment。

F<type><abi> 这指定函数指针的alignment，可选的type有：1、i:函数指针的alignment与函数的对齐方式无关，并且是<abi>的倍数。
2、n:函数指针的alignment是函数上指定的显式对齐方式的倍数，也是<abi>的倍数。

m:<mangling> 如果有指定，llvm names 在输出中会mangled（重命名）。有如下的mangling style 选项：1、e：ELF mangling，私有symbol有.L 前缀。2、m:
Mips mangling:私有symbol有$前缀。3、o:Mach-O mangling:私有symbol有L前缀，其它symbol有_(下划线)前缀。4、x：Windows x86 COFFmangling：私有symbol获得通常的前缀。
5、w：Windows COFF mangling：与x相似，不同之处在于普通C符号不接收_（下划线）前缀。6、a：XCOFF mangling：私有symbol获得L..前缀。

n<size1>:<size2>:<size3>... 这将为target CPU指定一组本机整数宽度（以位为单位）。 例如，对于32位PowerPC，它可能包含n32；对于PowerPC 64，它可能包含n32：64；
对于X86-64，它可能包含n8：16：32：64。 该集合的元素被认为可以有效地支持大多数常规算术运算。

ni:<address space0>:<address space1>:<address space2>...这将具有指定地址空间的指针类型指定为Non-Integral Pointer Type。 0地址空间不能指定为非整数。

在每个采用<abi>：<pref>的实例中，指定<pref> alignment是可选的。 如果省略，则前面的：也应省略，并且<pref>将等于<abi>。

mid-level optimizers使用data layout 字符串来改进代码，并且仅当它与最终code generator使用的字符串匹配时，此字符串才有效。

** Target Triple
module可以指定描述目标主机的target triple字符串。例如：
#+BEGIN_SRC
target triple = "x86_64-apple-macosx10.7.0"
#+END_SRC
target triple 字符串由一系列由减号字符（'-'）分隔的标识符组成。规范形式为：
#+BEGIN_SRC
ARCHITECTURE-VENDOR-OPERATING_SYSTEM
ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
#+END_SRC
此信息将传递给backend，以便它为正确的体系结构生成代码。可以使用-mtriple命令行选项在命令行中覆盖此设置。

** Pointer Aliasing Rules
任何memory访问都必须通过与该memory访问的地址范围相关联的指针值来完成，否则该行为是不确定的。指针值根据以下规则与地址范围相关联：

1、指针值与与其所基于的任何值相关联的地址相关联。

2、全局变量的地址与变量storage的地址范围相关联。

3、allocation instruction的结果值与allocated storage的地址范围相关联。

4、默认地址空间中的空指针没有地址关联。

5、任何地址空间中的undef值都没有地址。

6、除零以外的整数常量或从LLVM中未定义的函数返回的指针值可与通过LLVM提供的机制以外的机制分配的地址范围相关联。此类范围不得与LLVM提供的机制分配的地址范围重叠。

基于其它指针值来确定的指针值的规则：

1、由标量getelementptr操作形成的指针值基于getelementptr的指针类型的操作数。

2、向量getelementptr操作的结果的lane l中的指针基于getelementptr的指针矢量类型的操作数的lane l中的指针。

3、bitcast的结果值基于bitcast的operand。

4、由inttoptr形成的指针值基于（直接或间接）有助于计算指针值的所有指针值。

5、“基于”关系是可传递的。

** Volatile Memory Accesses
某些memory访问（例如load，store和llvm.memcpy）可能被标记为volatile。optimizer不得更改volatile操作的数量或相对于其他volatile操作更改其执行顺序。optimizer可以改变volatile
操作相对于non-volatile操作的顺序。

volatile load 或 store 可能具有其他target-specific的语义。任何volatile操作都可能产生副作用，并且任何volatile操作都可以读取或修改状态，而该状态不能通过常规load或store在此
模块中访问。volatile操作可能使用不指向内存的地址（如MMIO寄存器）。

volatile访问所允许的副作用是有限的。如果将非volatile存储器存储到给定地址是合法的，则volatile操作可能会修改该地址处的memory。volatile操作可能不会修改正在编译的模块可访问的
任何其他memory。volatile操作可能不会在当前模块中调用任何代码。

编译器可能会假定执行将在volatile操作之后继续进行，因此可以将修改memory或可能具有未定义行为的操作挂起通过volatile操作。

** Memory Model for Concurrent Operations
LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有platform-specific的方式来创建它们，并且我们定义了LLVM IR的行为。该模型的灵感来自C ++ 0x内存模型。
使用介绍可参考https://llvm.org/docs/Atomics.html

** Atomic Memory Ordering Constraint
atomic instruction（cmpxchg，atomicrmw，fence，automic load和automic store）采用排序参数，这些参数确定与它们同步的同一地址上的哪些其他atomic instruction。
关于ordering constraint，在https://llvm.org/docs/Atomics.html 也有介绍。

** Floating-Point Environment
默认的LLVM浮点环境假定浮点指令没有副作用。结果假设取整为最近的取整模式。 在这种环境下，不维护任何浮点异常状态。 因此，没有尝试创建或保留无效操作（SNaN）或除以零的异常。

** Fast-Math Flags
LLVM IR浮点运算（fneg，fadd，fsub，fmul，fdiv，frem，fcmp），phi，select和call可能会使用以下flags来启用不安全的浮点转换。

1、nnan
没有NaN，允许optimizations假设参数和结果不是NaN。 如果参数是nan，或者结果将是nan，则会生成poison value。

2、ninf
没有Infs，允许optimizations假设参数和结果不是+/- Inf。 如果参数为+/- Inf，或者结果为+/- Inf，则会生成poison value。

3、nsz
没有signed zero，允许optimizations将零参数或结果的符号视为无关紧要。

4、arcp
允许倒数-允许optimizations使用参数的倒数而不是执行除法。

5、contract
允许浮点收缩（例如，将乘法后接加法融合成乘加）。这不能重新组合以形成任意收缩。例如，（a * b）+（c * d）+ e不能转换为（a * b）+（（c * d）+ e）来创建两个fma运算。

6、afn
近似函数-允许用近似计算替代函数（正弦，对数，平方根等）。

7、reassoc
允许对浮点指令进行重新关联转换。 这可能会改变浮点数的结果。

8、fast
这个flag包含所有其它flags。

** Use-list Order Directives
use-list directives 对每个use-list的内存顺序进行编码，允许重新创建该顺序。<order-indexes>是分配给参考值使用的逗号分隔列表的索引。 引用值的use-list会按这些索引排序。

use-list directives 可能出现在函数的scope或全局scope。它们不是instructions，对IR 的语义也没有影响，当它们出现在函数内，它们必须位于函数最后的basic block的terminator
之后。

如果basic block 使用blockaddress()表达式来取它的地址，uselistorder_bb可以用来重排它们的use-list从函数范围外。

语法：
#+BEGIN_SRC
uselistorder <ty> <value>, { <order-indexes> }
uselistorder_bb @function, %block { <order-indexes> }
#+END_SRC

例子：
#+BEGIN_SRC
define void @foo(i32 %arg1, i32 %arg2) {
entry:
  ; ... instructions ...
bb:
  ; ... instructions ...

  ; At function scope.
  uselistorder i32 %arg1, { 1, 0, 2 }
  uselistorder label %bb, { 1, 0 }
}

; At global scope.
uselistorder i32* @global, { 1, 2, 0 }
uselistorder i32 7, { 1, 0 }
uselistorder i32 (i32) @bar, { 1, 0 }
uselistorder_bb @foo, %bb, { 5, 1, 3, 2, 0, 4 }
#+END_SRC

** Source Filename
源文件名字符串设置为原始module identifier，当通过clang前端从源代码进行编译时，该文件名将是已编译源文件的名称。IR和bitcode会保留它。

当前，对于在profile data中使用的local function生成一致的唯一全局标识符是必要的，该标识符将源文件名附加到local function名之前。

举例：
#+BEGIN_SRC
source_filename = "/path/to/source.c"
#+END_SRC

* Type System

* lazy symbol binding
Lazy binding is controlled by the -z option to the linker, ld. This option takes keywords as an argument; the keywords include (among others):

1、lazy

When generating an executable or shared library, mark it to tell the dynamic linker to defer function-call resolution to the point when the function is called (lazy binding), rather than at load time.

2、now

 When generating an executable or shared library, mark it to tell the dynamic linker to resolve all symbols when the program is started, or when the shared library is linked to using dlopen(), instead
of deferring function-call resolution to the point when the function is first called.

lazy binding的原因：

Doing things as late as possible:

(a) reduces the work incurred to start up；

(b) avoids that work altogether if that execution path is never taken. This is true not just for the linker, but any execution that you can delay until needed。
* runtime
Runtime describes software/instructions that are executed while your program is running, especially those instructions that you did not write explicitly,
but are necessary for the proper execution of your code.
* control dependency
程序执行过程中的控制依赖关系，厘清每条语句的执行依赖于其它哪些语句。A node (basic block) Y is control-dependent on another X iff X determines whether Y executes。
* storage class
A storage class in the context of C++ variable declarations is a type specifier that governs the lifetime, linkage, and memory location of objects。
A given object can have only one storage class. Variables defined within a block have automatic storage unless otherwise specified using the extern, static,
or thread_local specifiers. Automatic objects and variables have no linkage; they are not visible to code outside the block. Memory is allocated for them
automatically when execution enters the block and de-allocated when the block is exited.

* outgoing stack arguments
the caller has a preallocated area at the top of its stack frame to hold the arguments it supplies to other subroutines it calls. This area is sometimes
termed the outgoing arguments area or callout area。
* storage class specifier
auto register static extern _Thread_local
* function annotations
对函数参数，返回值的一种修饰限定，是一些可选项，在编译和链接时能传递更多信息。

C++ function annotations:https://docs.microsoft.com/en-us/cpp/code-quality/annotating-function-parameters-and-return-values?view=msvc-160

python function annotations:https://www.tutorialspoint.com/function-annotations-in-python
* poison value
poison is a special value that represents a violation of an assumption。
undef of type T is the set consisting of all defined values of T。
* tail call
函数在code block的结尾被调用，即为tail call。

* store 指令
store指令用于写memory。
* load指令
load指令用于读memory.
* sub指令
sub返回两个操作数的差值
